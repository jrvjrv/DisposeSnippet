<?xml version="1.0" encoding="utf-8"?>
<CodeSnippets
    xmlns="http://schemas.microsoft.com/VisualStudio/2005/CodeSnippet">
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>dispose</Title>
      <Description>Use on a class that implements the IDisposible interface.</Description>
      <Shortcut>disposeNoClass</Shortcut>
      <SnippetTypes>
        <SnippetType>Expansion</SnippetType>
      </SnippetTypes>
    </Header>
    <Snippet>
      <Declarations>
        <Literal Editable="false">
          <ID>classname</ID>
          <ToolTip>Class name</ToolTip>
          <Function>ClassName()</Function>
          <Default>ClassNamePlaceholder</Default>
        </Literal>
      </Declarations>
      <Code Language="CSharp" Kind="method decl">
        <![CDATA[
#region IDisposable implementation
	private bool _disposed;
	
	// Implement IDisposable.
	// Do not make this method virtual.
	// A derived class should not be able to override this method.
	public void Dispose() {
		// Check to see if Dispose has already been called.
    if( _disposed ) return;

    Dispose(true);
		// Take yourself off the Finalization queue
		// to prevent finalization code for this object
		// from executing a second time.
		GC.SuppressFinalize(this);
	}

   // Dispose(bool disposing) executes in two distinct scenarios.
   // If disposing equals true, the method has been called directly
   // or indirectly by a user's code. Managed and unmanaged resources
   // can be disposed.
   // If disposing equals false, the method has been called by the 
   // runtime from inside the finalizer and you should not reference 
   // other objects. Only unmanaged resources can be disposed.
   protected virtual void Dispose(bool disposing) {
		// Check to see if Dispose has already been called.
    if( _disposed ) return;

    // If disposing equals true, dispose all managed
		// and unmanaged resources.
		if( disposing ) {
			// Dispose managed resources.
		}
    
		// Release unmanaged resources. If disposing is false, 
		// only the following code is executed.

		// Note that this is not thread safe.
		// Another thread could start disposing the object
		// after the managed resources are disposed,
		// but before the disposed flag is set to true.
		// If thread safety is necessary, it must be
		// implemented by the client.
		_disposed = true;         
  }

   // Use C# destructor syntax for finalization code.
   // This destructor will run only if the Dispose method 
   // does not get called.
   // It gives your base class the opportunity to finalize.
   // Do not provide destructors in types derived from this class.
   ~$classname$() {
		// Check to see if Dispose has already been called.
    if( _disposed ) return;

    // Do not re-create Dispose clean-up code here.
		// Calling Dispose(false) is optimal in terms of
		// readability and maintainability.
		Dispose(false);
   }
#endregion
]]>
      </Code>
    </Snippet>
  </CodeSnippet>
</CodeSnippets>